/*
Простыми словами: коллбэк — это функция, которая должна быть выполнена после того, как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).
В JavaScript функции — это объекты. Поэтому функции могут принимать другие функции в качестве аргументов, а также функции могут возвращать функции в качестве результата. Функции, которые это умеют, называются функциями высшего порядка. А любая функция, которая передается как аргумент, называется callback-функцией.
*/

//пример коллбека с указанием функции коллбека прямо в аргументе
function doHomework(subject, callback) {
    alert(`Starting my ${subject} homework.`);
    callback();
  }
  
  doHomework('math', function() {
    alert('Finished my homework');
  });

//пример коллбека с выносом коллбек функции отдельно
function doHomework(subject, callback) {
    alert(`Starting my ${subject} homework.`);
    callback();
  }
  function alertFinished(){
    alert('Finished my homework');
  }
  doHomework('math', alertFinished);

//PROMISE (по англ. promise, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.

//синтаксис создания promise
let promise = new Promise(function(resolve, reject) {
    // функция-исполнитель (executor)
  });

//Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.

//Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя. Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:
//resolve(value) — если работа завершилась успешно, с результатом value.
//reject(error) — если произошла ошибка, error – объект ошибки.

//У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
//state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
//result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

//пример успешного выполнения с resolve
let promise = new Promise(function(resolve, reject) {
    // эта функция выполнится автоматически, при вызове new Promise
  
    // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
    setTimeout(() => resolve("done"), 1000);
  });

//пример провального выполнения с reject
let promise = new Promise(function(resolve, reject) {
    // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
    setTimeout(() => reject(new Error("Whoops!")), 1000);
  });

//Может быть что-то одно: либо результат, либо ошибка
let promise = new Promise(function(resolve, reject) {
    resolve("done");
  
    reject(new Error("…")); // игнорируется
    setTimeout(() => resolve("…")); // игнорируется
  });

//использование then с промисами
let promise = new Promise(function(resolve, reject) {
    setTimeout(() => resolve("done!"), 1000);
  });
  
  // resolve запустит первую функцию, переданную в .then
  promise.then(
    result => alert(result), // выведет "done!" через одну секунду
    error => alert(error) // не будет запущена
  );

//catch - Если мы хотели бы только обработать ошибку
let promise = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error("Ошибка!")), 1000);
  });
  
  // .catch(f) это то же самое, что promise.then(null, f)
  promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду

//finally - выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
new Promise((resolve, reject) => {
    /* сделать что-то, что займёт время, и после вызвать resolve/reject */
  })
    // выполнится, когда промис завершится, независимо от того, успешно или нет
    //.finally(() => "остановить индикатор загрузки"
    //.then(result) => "показать результат, err => показать ошибку";
//Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
//Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
//Это очень удобно, потому что finally не предназначен для обработки результата промиса. Так что он просто пропускает его через себя дальше.