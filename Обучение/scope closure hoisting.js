/*
LexicalEnvironment - связанный с функцией внутренний (скрытый) объект, называемый лексическим окружением
Объект лексического окружения состоит из двух частей:
1) Environment Record – объект, в котором как свойства хранятся все локальные переменные 
(а также некоторая другая информация, такая как значение this).
2) Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи 
(снаружи от текущих фигурных скобок).

Function Declaration - В отличие от переменных, объявленных с помощью let, они полностью инициализируются не тогда, 
когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение.
Функции инициализируются с null при инициализации скрипта, а при начале выполнения присваиваются прописанные данные

Есть внутреннее и внещнее лексическое окружение - внутреннее внутри самой функции, внешнее за пределами фигурных скобок. У внутреннего при этом есть ссылка на внешнее

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Один вызов – одно лексическое окружение
новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.
И, если функция вызывается несколько раз, то для каждого вызова будет своё лексическое окружение, со своими, специфичными для этого вызова, локальными переменными и параметрами.

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ. В некоторых языках это невозможно, или функция должна быть написана специальным образом, чтобы получилось замыкание. Но, как было описано выше, в JavaScript, все функции изначально являются замыканиями

Поднятие - Интерпретатор JavaScript всегда незаметно для нас перемещает («поднимает») объявления функций и переменных в начало области видимости. Формальные параметры функций и встроенные переменные языка, очевидно, изначально уже находятся в начале.

Инкапсуляция - является одним из ключевых понятий объектно-ориентированного программирования и представляет сокрытие состояния объекта от прямого доступа извне. По умолчанию все свойства объектов являются публичными, общедоступными, и мы к ним можем обратиться из любого места программы.
*/


//Пример замыкания, функция внутри запомнила (замкнула) функцию путем сохранения в переменной
function createCalcFunction (n) {
    return function () {
        console.log(1000 * n);
    }
};
const newCalcFunction = createCalcFunction(42);
newCalcFunction(); //42000

//Поднятие. Две данные функции абсолютно эквивалентны
function foo() { 
    if (false) { 
        var x = 1; 
    } 
    return; 
    var y = 1; 
} 
function foo() { 
    var x, y; 
    if (false) { 
        x = 1; 
    } 
    return; 
    y = 1; 
}

//инкапсуляция
var x = 1; 
function hello () { 
    var x = 2; 
    console.log(x); 
} 
hello() // 2 
console.log(x); // 1