//синтаксическая конструкция try..catch, которая позволяет «ловить» ошибки и вместо падения делать что-то более осмысленное.
try {
    // код...
  } catch (err) {
    // обработка ошибки
  }
//Сначала выполняется код внутри блока try {...}.
//Если в нём нет ошибок, то блок catch(err) игнорируется: выполнение доходит до конца try и потом далее, полностью пропуская catch.
//Если же в нём возникает ошибка, то выполнение try прерывается, и поток управления переходит в начало catch(err). Переменная err (можно использовать любое имя) содержит объект ошибки с подробной информацией о произошедшем.
try {
    alert('Начало блока try');  // (1) <--
    lalala; // ошибка, переменная не определена!
    alert('Конец блока try (никогда не выполнится)');  // (2)
  } catch(err) {
    alert(`Возникла ошибка!`); // (3) <--
  }

//Объект ошибки - Когда возникает ошибка, JavaScript генерирует объект, содержащий её детали. Затем этот объект передаётся как аргумент в блок catch:
try {
    // ...
  } catch(err) { // <-- объект ошибки, можно использовать другое название вместо err
    // ...
  }

//name
//Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
//message
//Текстовое сообщение о деталях ошибки. В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:
//stack
//Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки.
try {
    lalala; // ошибка, переменная не определена!
  } catch(err) {
    alert(err.name); // ReferenceError
    alert(err.message); // lalala is not defined
    alert(err.stack); // ReferenceError: lalala is not defined at (...стек вызовов)
  
    // Можем также просто вывести ошибку целиком
    // Ошибка приводится к строке вида "name: message"
    alert(err); // ReferenceError: lalala is not defined
  }

//Блок «catch» без переменной - Если нам не нужны детали ошибки, в catch можно её пропустить:
try {
    // ...
  } catch { //  <-- без (err)
    // ...
  }

//пример на JSON parse
let json = "{ некорректный JSON }";
try {
  let user = JSON.parse(json); // <-- тут возникает ошибка...
  alert( user.name ); // не сработает
} catch (e) {
  // ...выполнение прыгает сюда
  alert( "Извините, в данных ошибка, мы попробуем получить их ещё раз." );
  alert( e.name );
  alert( e.message );
}
//вброс конкретной ошибки
let json = '{ "age": 30 }'; // данные неполны
try {
  let user = JSON.parse(json); // <-- выполнится без ошибок
  if (!user.name) {
    throw new SyntaxError("Данные неполны: нет имени"); // (*)
  }
  alert( user.name );
} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: Данные неполны: нет имени
}

//try…catch…finally - Конструкция try..catch может содержать ещё одну секцию: finally.
//Если секция есть, то она выполняется в любом случае:
//после try, если не было ошибок,
//после catch, если ошибки были.